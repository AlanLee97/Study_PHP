<?php
/* 原子匹配： 只能匹配一个字符
 * 特殊标识的原子

        原子	说明
    \d	匹配一个0-9
    \D	除了0-9以外的所有字符
    \w	a-zA-Z0-9_
    \W	除了0-9A-Za-z_以外的所有字符
    \s	匹配所有空白字符\n \t \r 空格
    \S	匹配所有非空白字符
    [ ]	指定范围的原子
 */
//     $pattern1 = "/\w/";
//     $pattern = "/a/";                    //正则表达式  a 为要匹配的字符
//     $string = "9fandirt7578t90ndwerb";    //目标匹配串
//     if(preg_match($pattern1, $string, $result)){
//         echo "匹配到了，结果为：<br>";
//         echo var_dump($result);
//     }else{
//         echo "未匹配到数据";
//     }

    
//元字符匹配： 匹配多个字符
/*
 * 
元字符	功能说明
*	是代表匹配前面的一个原子，匹配0次或者任意多次前面的字符。
+	匹配一次或多前前面的一个字符
?	前面的字符可有可无【可选】 有或没有
.	更标准一些应该把点算作原子。匹配除了\n以外的所有字符
|   或者。注：它的优先级最低了。
^	必须要以抑扬符之后的字符串开始
$	必须要以$之前的字符结尾
\b	词边界
\B	非边界
{m}	有且只能出现m次
{n,m}	可以出现n到m次
{m,}	至少m次，最大次数不限制
()	改变优先级或者将某个字符串视为一个整体，匹配到的数据取出来也可以使用它
 */

    //1. + 匹配最少1次前面的字符
//     $zz = '/\d+/';
//     $string = "迪奥和奥迪250都是我最爱";
    
//     //待会儿再试试中间没有0-9的情况
//     //$string = "迪奥和奥迪都是我最爱";

    //2. * 匹配0次或者任意多次前面的字符
    $zz = '/\w*/';
//     //$string = "!@!@!!@#@!$@#!";
    
//     //待会儿再试试中间没有0-9的情况
//     $string1 = "!a1@#!@#!abcABC#@#!";

    
    //3. ? 前面的字符出现0次或者1次，可有可无
//     $zz = '/ABC\d?ABC/';
//     $string = "ABC1ABC";
    
//     //待会儿再试试中间没有0-9的情况
//     $string1 = "ABC888888ABC";
//     $string2 = "ABCABC";

    
    //4. . (点) 匹配除\n以外的所有字符
//     $zz = '/gg./';
//     $string = "\nABC1ABC";
   
    
    //5. |（竖线），或者，优先级最低
    $zz = '/abc|bcd/';
    $string1 = "abccd";
    $string2 = "ggggbcd";
    
    
    //6. ^ （抑扬符），必须要以^之后的字符串开始
//     $zz = '/^小姐姐\w+/';
//     $string1 = "小姐姐abccdaaaasds";
//     //$string2没有以小姐姐开始
//     $string2 = "姐abccdaaaasds";
    
    
    //7. $ （美元符）必须要以$之前的字符结束
//     $zz = '/\d+努力$/';
//     $string1 = "12321124333努力";
//     //$string2
//     $string2 = "12311124112313力";

    
    //8. \b和\B 词边界和非词边界
    //例如：this是一个英文单词，后面加上一个空格，意味着这个词结束了，到达了这个词的边界
//     $zz = '/\w+\b/';
//     $string1 = "this is a apple";
//     $string2 = "thisis a apple";
//     $string3 = "thisisaapple";
    
    
    //9. {m}有且只能出现m次
//     $zz = '/喝\d{3}酒/';
//     $string1 = "喝988酒";
//     //$string2 = "喝98811酒";

    //10. {n,m} 可以出现n到m次
//     $zz = '/喝\d{1,3}酒/';
//     $string1 = "喝9酒";
//     $string2 = "喝9818酒";

    //11. {m,} 至少m次，最大次数不限制
//     $zz = '/喝\d{2,}/';
//     $string1 = "喝9";
//     $string2 = "喝98";
//     $string3 = "喝98122121";
   
    
    
//3. php 正则达达示中的模式修正符
    //1. i 不区分大小写
//     $pattern = '/ABC/i';
//     $string = '8988abc12313';
//     $string1 = '11111ABC2222'; 

    //2. m 视为多行
//     $pattern = '/^a\d+/m';
//     $string = "我的未来在自己手中我需要不断的努力
// a9是一个不错的字符表示
// 怎么办呢，其实需要不断奋进";

    //3. s 视为一行
//     $pattern = '/新的未来.+\d+/s';
//     $string = "新的未来
// 987654321";

    //4. x 忽略空白字符
//     $pattern = '/a b c /x';
//     $string = '学英语要从abc开始';
//     $string2 = '学英语要从a b c开始';

    //5. e 将匹配项找出来，进行替换
    
//替换模式
//     $pattern = "/(\w+) (\d+), (\d+)/";
//     $string = "{April 15, 2003}";
    
//     //'w'匹配字母，数字和下划线，'d'匹配0-99数字，'+'元字符规定其前导字符必须在目标对象中连续出现一次或多次
//     $replacement = "\$2";   //\$2 指向的是正则表达示的第一个(\d+)。相当于把15又取出来了,替换的时候，我写上\$2。将匹配项取出来，用来再次替换匹配的结果。
    
//     //字符串被替换为与第 n 个被捕获的括号内的子模式所匹配的文本
//     echo preg_replace($pattern, $replacement, $string);
    
    //6. U 贪婪模式控制
    //正则表达式默认是贪婪的，也就是尽可能的最大限度匹配。
//     $pattern = '/<div>.*<\/div>/U';     //U表示把正则的贪婪特性取消掉。让它找到了最近的匹配，就OK了。
//     $string = "<div>你好</div><div>我是</div>";
    
    //7. A 从目标字符串的开头开始匹配
//     $pattern = '/this/A';
//     $string = 'hello this is a ';   //匹配失败
//     $string1 = 'this is a ';        //成功匹配

    //8. D 结束$符后不准有回车
    $pattern = '/\w+this$/';
    $pattern1 = '/\w+this$/D';
    $string = "hellothis "; 
    $string1 = "hello
this "; 

//匹配模式  
    if(preg_match($pattern, $string, $matches)){
        echo '匹配到了，结果为：';
        var_dump($matches);
    }else{
        echo '没有匹配到';
    }

?>